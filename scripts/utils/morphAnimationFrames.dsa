// Improved MorphAnimationFrames.dsa using dthUtils functions
// This file handles the creation of morph animation keyframes with improved code organization

/**
 * Finds a control (morph, modifier, or pose) on a node by name
 * @param {DzNode} selectedNode - The node to search for controls
 * @param {string} controlName - Name of the control to find
 * @param {string} type - Type of control ("morph", "modifier", or "pose")
 * @returns {Object|null} The found control or null if not found
 */
function findControl(selectedNode, controlName, type) {
  var obj = selectedNode.getObject();

  if (type === "pose") {
    // Check node parameters for poses
    var numParams = selectedNode.getNumProperties();
    for (var p = 0; p < numParams; p++) {
      var param = selectedNode.getProperty(p);
      if (param.getName() === controlName || param.getLabel() === controlName) {
        return param;
      }
    }
  } else if (type === "morph") {
    // Use the utility function for morphs
    return getMorphPropFromNode(selectedNode, controlName);
  } else if (type === "modifier") {
    // Check modifiers specifically for Modifier/Shape types
    for (var m = 0; m < obj.getNumModifiers(); m++) {
      var mod = obj.getModifier(m);
      if (
        (mod.getLabel() === controlName || mod.getName() === controlName) &&
        mod.inherits("DzModifier")
      ) {
        return mod;
      }
    }
  }
  return null;
}

/**
 * Parses a control configuration entry
 * @param {Object|Array} config - Configuration entry for a control or group of controls
 * @returns {Object} Parsed configuration
 */
function parseControlConfig(config) {
  // Handle fence type directly
  if (config.type === "fence") {
    return {
      isLinked: false,
      isFence: true,
      controls: [],
    };
  }

  if (Array.isArray(config)) {
    return {
      isLinked: true,
      isFence: false,
      controls: config.map(function (item) {
        return {
          type: item.type,
          name: item.name,
          value: parseFloat(item.value),
          resetValue: item.reset !== undefined ? parseFloat(item.reset) : 0,
        };
      }),
    };
  } else {
    return {
      isLinked: false,
      isFence: false,
      controls: [
        {
          type: config.type,
          name: config.name,
          value: parseFloat(config.value),
          resetValue: config.reset !== undefined ? parseFloat(config.reset) : 0,
        },
      ],
    };
  }
}

/**
 * Sets all controls to their reset values at a specific frame
 * @param {Array} controlConfigs - Array of control configurations
 * @param {DzNode} selectedNode - Node containing the controls
 * @param {number} frame - Frame to reset controls at
 */
function resetAllControlsAtFrame(controlConfigs, selectedNode, frame) {
  var timeStep = Scene.getTimeStep();
  var processedControls = {}; // Track which controls we've already processed

  for (var i = 0; i < controlConfigs.length; i++) {
    var config = parseControlConfig(controlConfigs[i]);

    // Skip fence types as they don't have controls to reset
    if (config.isFence) {
      continue;
    }

    config.controls.forEach(function (control) {
      // Skip if we've already processed this control
      if (processedControls[control.name]) {
        return;
      }

      var controlMod = findControl(selectedNode, control.name, control.type);

      if (controlMod) {
        if (control.type === "pose") {
          controlMod.setValue(control.resetValue);
        } else {
          var channel = controlMod.getValueChannel();
          // Use createMorphFrame for better consistency
          createMorphFrame(channel, frame, control.resetValue);
        }
        processedControls[control.name] = true;
        verbose(
          "Reset " +
            control.type +
            " " +
            control.name +
            " to " +
            control.resetValue
        );
      }
    });
  }
}

/**
 * Go to N frames before the last frame
 * @param {number} nParam - Number of frames from the end (default: 1)
 */
function goToNLastFrame(nParam) {
  var n = nParam || 1;
  // Get the current animation range
  var animRange = Scene.getAnimRange();

  // Get the time step (duration of one frame)
  var timeStep = Scene.getTimeStep();

  // Calculate the last frame number
  var lastFrame = Math.floor(animRange.end / timeStep);

  // Calculate the N-from-last frame number
  var targetFrame = lastFrame - n;

  // Set the current frame
  Scene.setFrame(targetFrame);
}

/**
 * Adds morph animation frames to a node based on control configurations
 * @param {DzNode} oNodeRoot - Node to add morphs to
 * @param {Array} controlConfigs - Array of control configurations
 */
function addMorphAnimationFrames(oNodeRoot, controlConfigs) {
  var selectedNode = oNodeRoot;

  // Get the time step for animation
  var timeStep = Scene.getTimeStep();
  print("Time step: " + timeStep.valueOf());

  // Calculate total frames needed (accounting for linked controls counting as one frame)
  var totalFrames = controlConfigs.length;

  // First, extend the timeline to accommodate our controls
  var currentRange = Scene.getAnimRange();
  var currentFrame = Scene.getFrame(); // Get current frame position
  var framesNeeded = totalFrames + 2; // +2 for cleanup frames before and after

  // Calculate new end point
  var newEndPoint =
    currentRange.start + timeStep * (currentFrame + framesNeeded);
  if (newEndPoint > currentRange.end) {
    // Use utility function to add frames
    var framesToAdd = Math.ceil((newEndPoint - currentRange.end) / timeStep);
    addFramesToAnim(framesToAdd);

    var oldFrames = currentRange.end / timeStep;
    var newFrames = Scene.getAnimRange().end / timeStep;
    print(
      "Timeline extended from " +
        oldFrames +
        " frames to " +
        newFrames +
        " frames"
    );
  }

  // Track missing controls and all found controls
  var missingControls = [];
  var allFoundControls = [];

  // Check if there is a selected node
  if (selectedNode) {
    var label = selectedNode.getLabel();
    print("Selected node label: " + label);

    // Get the object to access controls
    var obj = selectedNode.getObject();

    // Gather all available controls for diagnostics
    collectAvailableControls(selectedNode, allFoundControls);

    // Use current frame as start frame
    var startFrame = currentFrame;
    print("Starting at frame: " + startFrame);
    var endFrame = startFrame + totalFrames + 1;

    // Reset frames
    Scene.setFrame(startFrame - 1);
    resetAllControlsAtFrame(controlConfigs, selectedNode, startFrame - 1);

    // Apply reset to all frames first
    for (var frame = startFrame; frame < endFrame; frame++) {
      Scene.setFrame(frame);
      resetAllControlsAtFrame(controlConfigs, selectedNode, frame);
    }

    // Then set each control or control group to its target value at its specific frame
    for (var i = 0; i < controlConfigs.length; i++) {
      var config = parseControlConfig(controlConfigs[i]);
      var targetFrame = startFrame + i;
      Scene.setFrame(targetFrame);

      // If this is a fence type, just move to the next frame without setting any controls
      if (config.isFence) {
        print("Frame " + targetFrame + ": Fence (empty keyframe)");
        continue;
      }

      // Ensure we set all controls at exactly the same frame
      var controlsToSet = [];

      // First, gather all controls
      config.controls.forEach(function (control) {
        var currentControl = findControl(
          selectedNode,
          control.name,
          control.type
        );

        if (currentControl) {
          controlsToSet.push({
            control: currentControl,
            name: control.name,
            value: control.value,
            type: control.type,
          });
        } else {
          missingControls.push(control.name);
          print(
            "⚠️ Control not found: " +
              control.name +
              " (type: " +
              control.type +
              ")"
          );
        }
      });

      // Then set all values at once for this frame
      controlsToSet.forEach(function (controlData) {
        if (controlData.type === "pose") {
          controlData.control.setValue(controlData.value);
        } else {
          var valueChannel = controlData.control.getValueChannel();
          // Use the utility function for creating morph frames
          createMorphFrame(valueChannel, targetFrame, controlData.value);
        }
        print(
          "Frame " +
            targetFrame +
            ": Set " +
            controlData.type +
            " " +
            controlData.name +
            " = " +
            controlData.value
        );
      });
    }

    // Set all animations to use linear interpolation
    setLinearInterp([selectedNode]);

    // Go to frame before the end to view the animation
    goToNLastFrame(2);

    // If there were any missing controls, print all available controls
    reportMissingControls(missingControls, allFoundControls);
  } else {
    print("No nodes are selected.");
  }
}

/**
 * Collects all available controls on a node for diagnostic purposes
 * @param {DzNode} selectedNode - Node to collect controls from
 * @param {Array} allFoundControls - Array to populate with control info
 */
function collectAvailableControls(selectedNode, allFoundControls) {
  var obj = selectedNode.getObject();
  var numMods = obj.getNumModifiers();

  // Check modifiers (morphs and modifier/shapes)
  for (var m = 0; m < numMods; m++) {
    var mod = obj.getModifier(m);
    var modLabel = mod.getLabel() || "";
    var modName = mod.getName() || "";
    var type = mod.inherits("DzModifier") ? "modifier" : "morph";
    allFoundControls.push({
      type: type,
      label: modLabel,
      name: modName,
    });
  }

  // Check parameters (poses)
  var numParams = selectedNode.getNumProperties();
  for (var p = 0; p < numParams; p++) {
    var param = selectedNode.getProperty(p);
    var paramLabel = param.getLabel() || "";
    var paramName = param.getName() || "";
    allFoundControls.push({
      type: "pose",
      label: paramLabel,
      name: paramName,
    });
  }
}

/**
 * Reports any missing controls and prints available controls for diagnostics
 * @param {Array} missingControls - Array of missing control names
 * @param {Array} allFoundControls - Array of all available controls
 */
function reportMissingControls(missingControls, allFoundControls) {
  if (missingControls.length > 0) {
    print(
      "\n⚠️ Some controls were not found. Here is a complete list of all available controls:"
    );

    // Sort the controls for better readability
    allFoundControls.sort(function (a, b) {
      return a.label.localeCompare(b.label);
    });

    for (var i = 0; i < allFoundControls.length; i++) {
      var control = allFoundControls[i];
      print(
        "  " +
          control.type +
          ": " +
          control.label +
          (control.name !== control.label
            ? " (Name: " + control.name + ")"
            : "")
      );
    }
  }
}

/**
 * Main function to generate a morph animation with proper undo support
 * @param {DzNode} oNodeRoot - Node to animate
 * @param {Array} morphConfigs - Array of morph configurations
 */
function generateMorphAnimation(oNodeRoot, morphConfigs) {
  beginUndo();

  Scene.setTime(0);

  addMorphAnimationFrames(oNodeRoot, morphConfigs);

  acceptUndo("Generate morph animation");

  MessageBox.information("Morph animation successfully generated!", "", "");
}
