// Complete DAZ Studio Licensing Report Generator
// Self-contained script that analyzes scene assets and generates licensing report

var dir_self = new DzDir(new DzFileInfo(getScriptFileName()).path());
include(dir_self.filePath("getInstalledProducts.dsa"));
include(dir_self.filePath("getUsedAssets.dsa"));

var dimManifestPath =
  "C:/Users/Public/Documents/DAZ 3D/InstallManager/ManifestFiles";
var outputPath = "D:/DAZ 3D/My DAZ 3D Library/Scripts/licensing_report.txt";

function generateLicensingReport() {
  print("=== DAZ STUDIO LICENSING REPORT GENERATOR ===");

  // Get scene assets
  print("Analyzing scene assets...");
  var usedAssets = getUsedAssets();

  // Get installed products
  print("Loading installed products database...");
  var installedProducts = getInstalledProducts();

  if (usedAssets.length === 0) {
    print("No assets found in scene!");
    return;
  }

  if (installedProducts.length === 0) {
    print("No installed products found!");
    return;
  }

  // DEBUG: Print some assets and products to see what we're working with
  print("\n=== DEBUG INFO ===");
  print("Looking for Golden Palace and anatomy assets...");

  var foundGoldenPalace = false;
  var foundAnatomy = false;

  for (var i = 0; i < Math.min(100, usedAssets.length); i++) {
    var asset = usedAssets[i];
    var assetLower = asset.name.toLowerCase();
    var techLower = asset.technicalName.toLowerCase();

    if (
      assetLower.indexOf("palace") !== -1 ||
      techLower.indexOf("palace") !== -1 ||
      assetLower.indexOf("vagina") !== -1 ||
      techLower.indexOf("vagina") !== -1 ||
      assetLower.indexOf("labia") !== -1 ||
      techLower.indexOf("labia") !== -1 ||
      assetLower.indexOf("clitoris") !== -1 ||
      techLower.indexOf("clitoris") !== -1 ||
      assetLower.indexOf("anus") !== -1 ||
      techLower.indexOf("anus") !== -1 ||
      assetLower.indexOf("genital") !== -1 ||
      techLower.indexOf("genital") !== -1 ||
      assetLower.indexOf("anatomy") !== -1 ||
      techLower.indexOf("anatomy") !== -1
    ) {
      print(
        "  - " +
          asset.type +
          ": '" +
          asset.name +
          "' (tech: '" +
          asset.technicalName +
          "')"
      );
      if (assetLower.indexOf("palace") !== -1) foundGoldenPalace = true;
      foundAnatomy = true;
    }
  }

  if (!foundGoldenPalace && !foundAnatomy) {
    print("  - No Golden Palace or anatomy assets found!");
    print("  - This suggests either:");
    print("    1. Golden Palace is not loaded in this scene");
    print("    2. Golden Palace nodes are named differently");
    print("    3. Golden Palace morphs are at zero value");
    print("");
    print("  Sample of all assets found:");
    for (var i = 0; i < Math.min(20, usedAssets.length); i++) {
      var asset = usedAssets[i];
      print("    - " + asset.type + ": '" + asset.name + "'");
    }
  }

  print("\nGolden Palace in installed products:");
  var foundGPProduct = false;
  for (var i = 0; i < installedProducts.length; i++) {
    var product = installedProducts[i];
    if (
      product.name.toLowerCase().indexOf("palace") !== -1 ||
      product.name.toLowerCase().indexOf("anatomy") !== -1 ||
      product.name.toLowerCase().indexOf("genital") !== -1
    ) {
      print("  - '" + product.name + "' (SKU: " + product.sku + ")");
      foundGPProduct = true;
    }
  }
  if (!foundGPProduct) {
    print("  - No Golden Palace products found in DIM manifests");
    print("  - Golden Palace is likely manually installed");
  }

  print("=== END DEBUG ===\n");

  print(
    "Matching " +
      usedAssets.length +
      " assets against " +
      installedProducts.length +
      " products..."
  );

  // Perform enhanced matching with grouping
  var matchResults = performEnhancedMatching(usedAssets, installedProducts);

  // Generate licensing report
  writeLicensingReport(matchResults);

  print("Licensing report generated successfully!");
}

// ===========================================
// MATCHING FUNCTIONS
// ===========================================

function performEnhancedMatching(usedAssets, installedProducts) {
  var exactMatches = {};
  var partialMatches = {};
  var unmatchedAssets = [];

  // Create lookup maps for fast searching
  var productByName = {};
  var productByPartialName = {};

  for (var i = 0; i < installedProducts.length; i++) {
    var product = installedProducts[i];
    var productName = String(product.name || "").toLowerCase();
    productByName[productName] = product;

    // Also index by key words for partial matching
    var words = productName.split(/[\s\-_]+/);
    for (var j = 0; j < words.length; j++) {
      if (words[j].length > 3) {
        if (!productByPartialName[words[j]]) {
          productByPartialName[words[j]] = [];
        }
        productByPartialName[words[j]].push(product);
      }
    }
  }

  // First pass: exact matches
  for (var i = 0; i < usedAssets.length; i++) {
    var asset = usedAssets[i];
    var assetName = String(asset.name || "").toLowerCase();
    var matched = false;

    // Try exact product name match
    if (productByName[assetName]) {
      addToGroup(
        exactMatches,
        productByName[assetName],
        asset,
        100,
        "Exact product name match"
      );
      matched = true;
    }

    if (!matched) {
      // Try partial matching with high confidence
      var bestPartialMatch = findBestPartialMatch(asset, installedProducts);
      if (bestPartialMatch && bestPartialMatch.confidence >= 70) {
        addToGroup(
          exactMatches,
          bestPartialMatch.product,
          asset,
          bestPartialMatch.confidence,
          bestPartialMatch.reason
        );
        matched = true;
      }
    }

    if (!matched) {
      // Try loose matching for partial matches
      var looseMatch = findBestPartialMatch(asset, installedProducts);
      if (looseMatch && looseMatch.confidence >= 30) {
        addToGroup(
          partialMatches,
          looseMatch.product,
          asset,
          looseMatch.confidence,
          looseMatch.reason
        );
        matched = true;
      }
    }

    if (!matched) {
      unmatchedAssets.push(asset);
    }
  }

  // Convert to sorted arrays
  var exactArray = Object.keys(exactMatches)
    .map(function (key) {
      return exactMatches[key];
    })
    .sort(function (a, b) {
      return b.totalAssets - a.totalAssets;
    });

  var partialArray = Object.keys(partialMatches)
    .map(function (key) {
      return partialMatches[key];
    })
    .sort(function (a, b) {
      if (b.confidence !== a.confidence) {
        return b.confidence - a.confidence;
      }
      return b.totalAssets - a.totalAssets;
    });

  return {
    exactMatches: exactArray,
    partialMatches: partialArray,
    unmatchedAssets: unmatchedAssets,
    totalAssets: usedAssets.length,
    totalMatched:
      exactArray.reduce(function (sum, group) {
        return sum + group.totalAssets;
      }, 0) +
      partialArray.reduce(function (sum, group) {
        return sum + group.totalAssets;
      }, 0),
  };
}

function addToGroup(groups, product, asset, confidence, reason) {
  var productKey = product.name;

  if (!groups[productKey]) {
    groups[productKey] = {
      product: product,
      assets: [],
      confidence: confidence,
      category: categorizeProduct(product),
      totalAssets: 0,
    };
  }

  groups[productKey].assets.push({
    asset: asset,
    confidence: confidence,
    matchReason: reason,
  });
  groups[productKey].totalAssets++;

  // Keep highest confidence for the group
  if (confidence > groups[productKey].confidence) {
    groups[productKey].confidence = confidence;
  }
}

function findBestPartialMatch(asset, installedProducts) {
  var assetName = String(asset.name || "").toLowerCase();
  var assetTech = String(asset.technicalName || "").toLowerCase();

  var bestMatch = null;
  var highestConfidence = 0;

  for (var i = 0; i < installedProducts.length; i++) {
    var product = installedProducts[i];
    var productName = String(product.name || "").toLowerCase();
    var confidence = 0;
    var reason = "";

    // Direct substring matches
    if (productName.indexOf(assetName) !== -1 && assetName.length > 3) {
      confidence = 80;
      reason = "Asset name found in product";
    } else if (
      assetName.indexOf(productName) !== -1 &&
      productName.length > 3
    ) {
      confidence = 75;
      reason = "Product name found in asset";
    } else if (productName.indexOf(assetTech) !== -1 && assetTech.length > 3) {
      confidence = 70;
      reason = "Technical name match";
    } else {
      // Word-by-word matching
      var assetWords = assetName.split(/[\s\-_]+/);
      var productWords = productName.split(/[\s\-_]+/);
      var matches = 0;

      for (var j = 0; j < assetWords.length; j++) {
        if (assetWords[j].length > 2) {
          for (var k = 0; k < productWords.length; k++) {
            if (assetWords[j] === productWords[k]) {
              matches++;
              confidence += 15;
            }
          }
        }
      }

      if (matches > 0) {
        reason = matches + " word matches";
        if (matches >= 2) confidence += 10; // Bonus for multiple matches
      }
    }

    if (confidence > highestConfidence) {
      highestConfidence = confidence;
      bestMatch = {
        product: product,
        confidence: confidence,
        reason: reason,
      };
    }
  }

  return bestMatch;
}

function findBestProductMatch(asset, installedProducts) {
  var bestMatch = null;
  var highestConfidence = 0;

  for (var i = 0; i < installedProducts.length; i++) {
    var product = installedProducts[i];
    var confidence = calculateMatchConfidence(asset, product);

    if (confidence > highestConfidence) {
      highestConfidence = confidence;
      bestMatch = {
        product: product,
        confidence: confidence,
        matchReason: getMatchReason(confidence),
      };
    }
  }

  return bestMatch;
}

function calculateMatchConfidence(asset, product) {
  var assetName = String(asset.name || "").toLowerCase();
  var assetTechName = String(asset.technicalName || "").toLowerCase();
  var productName = String(product.name || "").toLowerCase();

  var confidence = 0;

  // Special high-priority product matching first
  // Golden Palace detection
  if (
    (assetName.match(/golden.*palace|palace.*gen|goldenpalace/i) ||
      assetTechName.match(/golden.*palace|palace.*gen|goldenpalace/i)) &&
    productName.match(/golden.*palace|palace/i)
  ) {
    confidence += 85;
  }

  // Genesis base figure detection
  if (
    assetName.match(
      /genesis.*8\.1.*female|genesis.*8.*female|genesis.*9.*female/i
    ) &&
    productName.match(/genesis.*starter|genesis.*essential/i)
  ) {
    confidence += 80;
  }

  // Body/Head morphs detection
  if (
    assetTechName.match(/^(pbm|phm|fbm)/i) &&
    productName.match(/body.*morph|head.*morph|morph.*kit/i)
  ) {
    confidence += 70;
  }

  // DJ Yua character detection
  if (
    (assetName.match(/yua|dj.*yua/i) || assetTechName.match(/yua/i)) &&
    productName.match(/yua/i)
  ) {
    confidence += 80;
  }

  // Exact name match
  if (assetName === productName) {
    confidence += 95;
  }
  // Strong partial matches
  else if (
    productName.indexOf(assetName) !== -1 ||
    assetName.indexOf(productName) !== -1
  ) {
    confidence += 75;
  }
  // Technical name matches
  else if (
    productName.indexOf(assetTechName) !== -1 ||
    assetTechName.indexOf(productName) !== -1
  ) {
    confidence += 65;
  }

  // Word matching with better scoring
  var assetWords = assetName.split(/[\s\-_]+/);
  var productWords = productName.split(/[\s\-_]+/);
  var matchedWords = 0;

  for (var i = 0; i < assetWords.length; i++) {
    if (assetWords[i].length > 2) {
      for (var j = 0; j < productWords.length; j++) {
        if (assetWords[i] === productWords[j]) {
          matchedWords++;
          confidence += 12;
        }
      }
    }
  }

  // Bonus for multiple word matches
  if (matchedWords >= 2) {
    confidence += 15;
  }

  // Genesis version matching
  if (
    assetName.indexOf("genesis") !== -1 &&
    productName.indexOf("genesis") !== -1
  ) {
    confidence += 20;
  }

  // Morph pattern matching
  if (asset.type === "Morph") {
    // PBM/PHM/FBM morphs
    if (assetTechName.match(/^(pbm|phm|fbm|ctrl)/i)) {
      if (productName.match(/morph|body|head|control|shape/i)) {
        confidence += 20;
      }
      // Special Zev0 morph detection
      if (productName.match(/200.*plus|head.*body.*morph|zev0/i)) {
        confidence += 25;
      }
    }

    // Bend control morphs
    if (
      assetTechName.match(/bend|control/i) &&
      productName.match(/bend.*control|control/i)
    ) {
      confidence += 30;
    }
  }

  // Character specific matching
  if (assetName.match(/lara|croft|yua|victoria|genesis/i)) {
    var assetChar = assetName.match(/lara|croft|yua|victoria|genesis/i)[0];
    if (productName.indexOf(assetChar) !== -1) {
      confidence += 25;
    }
  }

  // Lower threshold for common base assets
  if (
    productName.match(/starter.*essential|genesis.*base|joint.*corrective/i)
  ) {
    confidence += 10; // Small boost for base products
  }

  return Math.min(confidence, 100);
}

function getMatchReason(confidence) {
  if (confidence >= 95) return "Exact match";
  if (confidence >= 75) return "Strong match";
  if (confidence >= 65) return "Good match";
  if (confidence >= 50) return "Likely match";
  if (confidence >= 30) return "Possible match";
  return "Weak match";
}

function categorizeProduct(product) {
  var name = String(product.name || "").toLowerCase();

  if (name.match(/genesis.*starter|genesis.*essential/)) return "Base Figure";
  if (
    name.match(
      /joint.*corrective|jcm.*base|body.*morphs.*genesis|head.*morphs.*genesis/
    )
  )
    return "Base Morphs";
  if (name.match(/200.*plus.*morph|head.*body.*morph|zev0.*morph/))
    return "Morphs";
  if (name.match(/morph|shape|bend.*control|body.*control|expressive/))
    return "Morphs";
  if (name.match(/hair/)) return "Hair";
  if (name.match(/outfit|cloth|dress|shirt|pants|bikini|lingerie/))
    return "Clothing";
  if (name.match(/golden.*palace|palace.*gen|anatomy|anatomical.*element/))
    return "Anatomy";
  if (name.match(/pose|animation/)) return "Poses/Animation";
  if (name.match(/skin|texture|material|makeup|perfectly.*imperfect/))
    return "Textures";
  if (name.match(/environment|hdri|scene|crew.*room/)) return "Environment";
  if (name.match(/character|hd.*for|yua.*hd|victoria|genesis.*female/))
    return "Character";
  if (name.match(/daz.*studio|install.*manager/)) return "Software";

  return "Other";
}

// ===========================================
// REPORT GENERATION
// ===========================================

function writeLicensingReport(matchResults) {
  try {
    var file = new DzFile(outputPath);
    if (!file.open(DzFile.WriteOnly | DzFile.Truncate)) {
      print("ERROR: Cannot write to: " + outputPath);
      return;
    }

    // Header
    file.writeLine("=== DAZ STUDIO LICENSING REPORT ===");
    file.writeLine("Generated: " + new Date().toString());
    file.writeLine("Scene: " + Scene.getFilename());
    file.writeLine("");

    // Summary
    var totalExactMatches = matchResults.exactMatches.reduce(function (
      sum,
      group
    ) {
      return sum + group.totalAssets;
    },
    0);
    var totalPartialMatches = matchResults.partialMatches.reduce(function (
      sum,
      group
    ) {
      return sum + group.totalAssets;
    },
    0);
    var matchRate = (
      ((totalExactMatches + totalPartialMatches) / matchResults.totalAssets) *
      100
    ).toFixed(1);

    file.writeLine("SUMMARY:");
    file.writeLine("- Total assets in scene: " + matchResults.totalAssets);
    file.writeLine(
      "- Direct product matches: " +
        totalExactMatches +
        " assets in " +
        matchResults.exactMatches.length +
        " products"
    );
    file.writeLine(
      "- Partial matches: " +
        totalPartialMatches +
        " assets in " +
        matchResults.partialMatches.length +
        " products"
    );
    file.writeLine(
      "- Unmatched assets: " + matchResults.unmatchedAssets.length
    );
    file.writeLine("- Overall match rate: " + matchRate + "%");
    file.writeLine("");

    file.writeLine("PRODUCTS IDENTIFIED FOR LICENSING REVIEW:");
    file.writeLine("=========================================");

    // Exact matches first
    if (matchResults.exactMatches.length > 0) {
      file.writeLine("");
      file.writeLine("CONFIRMED PRODUCTS (Direct Matches):");
      file.writeLine("------------------------------------");

      for (var i = 0; i < matchResults.exactMatches.length; i++) {
        var group = matchResults.exactMatches[i];
        file.writeLine(
          "âœ“ " +
            group.product.artist +
            " - " +
            group.product.name +
            " (SKU: " +
            group.product.sku +
            ")"
        );
        file.writeLine("  Assets Used: " + group.totalAssets);
        file.writeLine("  Category: " + group.category);
        file.writeLine("  Commercial License: [ ] Verified  [ ] Needs Check");

        // Show top assets
        var topAssets = group.assets.slice(0, 5);
        if (topAssets.length > 0) {
          file.writeLine(
            "  Key Assets: " +
              topAssets
                .map(function (a) {
                  return a.asset.name;
                })
                .join(", ")
          );
        }
        file.writeLine("");
      }
    }

    // Partial matches
    if (matchResults.partialMatches.length > 0) {
      file.writeLine("LIKELY PRODUCTS (Partial Matches):");
      file.writeLine("----------------------------------");

      for (var i = 0; i < matchResults.partialMatches.length; i++) {
        var group = matchResults.partialMatches[i];
        file.writeLine(
          "? " +
            group.product.artist +
            " - " +
            group.product.name +
            " (SKU: " +
            group.product.sku +
            ")"
        );
        file.writeLine("  Assets Used: " + group.totalAssets);
        file.writeLine("  Confidence: " + group.confidence + "%");
        file.writeLine("  Category: " + group.category);
        file.writeLine("  Verification: [ ] Confirmed  [ ] Different Product");
        file.writeLine("");
      }
    }

    // Important unmatched assets
    if (matchResults.unmatchedAssets.length > 0) {
      file.writeLine("UNIDENTIFIED ASSETS REQUIRING REVIEW:");
      file.writeLine("-------------------------------------");

      var importantUnmatched = matchResults.unmatchedAssets.filter(function (
        asset
      ) {
        return (
          asset.type === "Morph" ||
          asset.name.match(/character|outfit|hair|genesis|lara|yua/i)
        );
      });

      for (var i = 0; i < Math.min(importantUnmatched.length, 8); i++) {
        var asset = importantUnmatched[i];
        file.writeLine("! " + asset.name + " (" + asset.type + ")");
        file.writeLine("  Technical Name: " + asset.technicalName);
        file.writeLine(
          "  Status: [ ] Free Asset  [ ] Base Asset  [ ] Need to Identify"
        );
        file.writeLine("");
      }

      if (matchResults.unmatchedAssets.length > 8) {
        file.writeLine(
          "... and " +
            (matchResults.unmatchedAssets.length - 8) +
            " more unmatched assets"
        );
        file.writeLine("");
      }
    }

    // Action items
    file.writeLine("NEXT STEPS:");
    file.writeLine("----------");
    file.writeLine(
      "1. Review high confidence products for commercial licensing terms"
    );
    file.writeLine(
      "2. Verify medium confidence identifications against your purchase history"
    );
    file.writeLine("3. Research unidentified assets to determine their origin");
    file.writeLine(
      "4. Check DAZ store for current licensing terms of each product"
    );
    file.writeLine("5. Document commercial usage rights for your project");
    file.writeLine("");

    file.writeLine("COMMERCIAL USAGE CHECKLIST:");
    file.writeLine("---------------------------");
    file.writeLine("[ ] All products verified as owned");
    file.writeLine("[ ] Commercial licenses confirmed for paid products");
    file.writeLine("[ ] Free products checked for commercial restrictions");
    file.writeLine("[ ] Custom/modified content properly attributed");
    file.writeLine("[ ] Final render/project complies with all license terms");

    file.close();
    print("Licensing report written to: " + outputPath);

    // Show summary
    var totalExactMatches = matchResults.exactMatches.reduce(function (
      sum,
      group
    ) {
      return sum + group.totalAssets;
    },
    0);
    var totalPartialMatches = matchResults.partialMatches.reduce(function (
      sum,
      group
    ) {
      return sum + group.totalAssets;
    },
    0);
    var matchRate = (
      ((totalExactMatches + totalPartialMatches) / matchResults.totalAssets) *
      100
    ).toFixed(1);

    MessageBox.information(
      "Licensing Report Generated!\n\n" +
        "Direct matches: " +
        matchResults.exactMatches.length +
        " products (" +
        totalExactMatches +
        " assets)\n" +
        "Partial matches: " +
        matchResults.partialMatches.length +
        " products (" +
        totalPartialMatches +
        " assets)\n" +
        "Overall match rate: " +
        matchRate +
        "%\n\n" +
        "Report saved to:\n" +
        outputPath,
      "Licensing Analysis Complete",
      "&OK"
    );
  } catch (e) {
    print("ERROR writing licensing report: " + e.message);
  }
}

// Run the generator
generateLicensingReport();
